
def bubble_sort(a): # def- слово указывающее на определение функции `bubble_sort`, `а` - параметр или аргумент.
    # начало тела функции (пишется с отступом)
    to = len(a) - 1  # len() - функция которая возвращает длину массива (количество элементов в массиве).
    for k in range(to, 0, -1): # заголовок внешнего цикла (определяет до каких пор выполнять повторения)
        # начинается тело внешнего цикла (определяет, что будет выполняться, и пишется с отступом)
        swap = False # range- генератор последовательностей чисел (значений)      
        for i in range(k): # заголовок вложенного цикла
            # начинается тело вложенного цикла
            if a[i] > a[i + 1]: # заголовок условия 
                # начало тела условия
                tmp = a[i]    # доступ к элементам массива `а` по индексу `i`
                a[i] = a[i + 1]
                a[i + 1] = tmp                                                          
                swap = True  # конец тела условия, конец тела вложенного цикла
        if not swap:      
            return    # конец тела внешнего цикла, конец тела функции.
            
def unique(a):
    result = []
    b = a[:] # a[:]- копия массива, мы не хотим менять исходный массив
    bubble_sort(b) 
    if len(b) > 0: # если длина массива больше нуля (массив не пустой)
        result.append(b[0]) 
    for i in range(1, len(b)):  
        if b[i] != b[i - 1]:
            result.append(b[i])
    return result 
 

def my_range(start, stop, step): 
    """функция-генератор возвращает арифметическую прогрессию"""
    if step > 0:
        while start < stop:
            yield start 
            start = start + step
    elif step < 0:
        while start > stop:
            yield start  # yield - возвращает результат не завершая функцию/
            start = start + step        
    else:
        raise Exception('`step` cannot be zero')   # Выбрасываем программное исключение при 
                                                   # недопустимом аргументе         
        
        
def fibonacci(n):
    """функция-генератор возвращает последовательность Фибоначчи""" 
    f1 = -1
    f2 = 1
    for i in my_range(0, n, 1):
        f3 = f1 + f2 
        yield f3 
        f1 = f2
        f2 = f3 
        
        
def arrays_equal_in_any_order(a, b): 
    """ возвращает True, если заданные массивы содержат одни и те же элементы в любом порядке"""
    copy_a = a[:] # a[:]- копия массива, мы не хотим менять исходный массив
    copy_b = b[:]  # эта конструкция называется срез (slice) 
    bubble_sort(copy_a)
    bubble_sort(copy_b)
    return copy_a == copy_b
        
        
    

 