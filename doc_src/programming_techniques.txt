<!--VARIABLES {"title": "Приемы программирования", "SORT_ORDER": "17", 
"code": "programming_techniques"}-->

[TOC]

----------------------------------------------------------------------------------------------------
# О разделе   

В этом разделе рассматриваются решение типичных задач.

----------------------------------------------------------------------------------------------------
<!--i ["итерации"]-->
# Итерации

Итерация --- это повторение фрагмента программы по некоторому набору данных или по условию. 
Итерации требуются для решения очень большого количества задач в программировании.

Рассмотрим итерацию *по условию* на примере псевдокода. 

````
while <условие>:
    <действия>
````

При написании конкретного кода нам требуется определить две вещи:

- определить условие, при котором тело цикла выполняется;
- набор действий, которые выполняются в теле цикла.

Несколько более сложным для понимания вариантом итерации, является итерация по *набору данных*, 
однако она позволяет нам существенно сократить размер кода и улучшить его читаемость. 
Схема выглядит так:

````
for <переменная цикла> in <итерируемый объект>:
    <действия с переменной цикла>
    <другие действия>
````

В качестве итерируемого объекта может использоваться коллекция, генератор или, возможно другие 
подобные объекты. Цикл *for* последовательно выбирает из итерируемого объекта значения, присваивает
эти значения переменной цикла и выполняет определенные в теле цикла действия. Эти действия могут
использовать переменную цикла на чтении, изменения переменной в теле цикла, как правило не 
используются.

Применительно к спискам могут использоваться два основных вариантов итерации:

- перебор самих элементов списка, это делается также, как и для остальных коллекций;
- доступ по индексу, в этом случае может использоваться генератор последовательности `(range())`.

Этот вариант является более сложным, но он необходим в двух случаях:

    - когда нам нужны сами индексы;
    - когда требуется не по всей коллекции, а по ее части.


Итератор — это поведенческий паттерн, позволяющий последовательно обходить сложную коллекцию, 
без раскрытия деталей её реализации. Код использующий итератор зачастую вообще не имеет ссылок на 
коллекцию, с которой работает итератор. Итератор либо принимает коллекцию в параметрах конструктора 
при создании, либо возвращается самой коллекцией.

for в Python может использоваться для итерации по списку.
Источник: https://pythonim.ru/list/iteratsiya-spiska-python

Метод range() позволяет пользователю создавать серию элементов в указанном диапазоне. for вместе 
с функцией range() можно использовать для итерации по списку.

Цикл while Python можно использовать для перебора списка.

----------------------------------------------------------------------------------------------------
<!--i ["StringIO", "строковый буфер"]--><a name="string_buffer"></a>
# Эффективное построение строки

Часто требуется формировать строку путем последовательного наращения. При использовании операции
конкатенации каждый раз формируется новая строка, а конкатенируемые строки могут оставаться в памяти
какое-то время, пока их не соберет сборщик мусора:

![](<!--path pict-->StringIO_1.png) 

При большом количестве наращений (например в цикле) такой способ формирования строки может 
вызвать заметное замедление программы и кратковременный перерасход памяти. 

Для решения этой проблемы может быть использован класс стандартной библиотеки Python `StringIO`.

![](<!--path pict-->StringIO_2.png)

Объект `StringIO` сохраняет добавляемые фрагменты строк, не создавая ненужных объектов. 
Результирующая строка формируется один раз после всех необходимых наращений.

Пример см. в задаче [Шифрование](<!--page 03_07_final_tasks-->#crypting).

<!--i ["join()"]-->
Для использования объекта `StringIO` требуется импорт дополнительного модуля,
`from io import StringIO`. Есть более простой способ эффективной конкатенации с использованием 
метода `join()` объекта `str`(строки). В этом случае фрагменты строк собираются в список, а потом
объединяются в единую строку. При этом так же не расходуется память на промежуточные конкатенации.

Примеры см. в задачах:

- [Кодирование длин серий](<!--page 03_07_final_tasks-->#series_encoding)
- [Футбол](<!--page 03_07_final_tasks-->#football)
- [Римские числа](<!--page 4_python_drill-->#rome_number)

----------------------------------------------------------------------------------------------------
<!--i ["рекурсия"]-->
# Рекурсия

Рекурсия такой прием программирования, при котором функция вызывает сама себя. Рассмотрим наиболее 
известный пример рекурсии в задаче [Ханойские башни](
https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BD%D0%BE%D0%B9%D1%81%D0%BA%D0%B0%D1%8F_%D0%B1%D0%B0%D1%88%D0%BD%D1%8F).

````code
def hanoi(n, s1, s2, s3):
    if n < 1:
        return
    elif n < 2:
        yield s1, s3
    else:
        yield from hanoi(n-1, s1, s3, s2) # разворачивает генератор как for и возвращает значение
        yield s1, s3
        yield from hanoi(n-1, s2, s1, s3)
        
for i in hanoi(3, 1, 2, 3):
    print(i)        
````

В задаче требуется переложить *n* дисков  с одного стержня *s1* на другой *s3* используя оставшийся 
стержень *s2*. При решении данной задачи мы предполагаем что задача по перекладыванию *n-1* дисков
уже решена. Следовательно мы можем переложить *n-1* дисков со стержня *s1* на стержень *s2*, 
затем переложить 1 диск со стержня *s1* на стержень *s3* (что тривиально), а затем снова переложить
*n-1* дисков со стержня *s2* на стержень *s3*.

Для перекладывания *n-1* дисков мы можем вызвать ту же самую функцию `hanoi`, однако здесь есть
особенности. Во-первых, рекурсивный вызов должен происходить с уменьшением размера подзадачи. 
В данном случае уменьшение происходит на один диск (*n-1*). Во-вторых, рекурсивный вызов должен 
происходить до некоторого крайнего случая. В нашем примере когда *n* достигает значения 1, 
задача становится тривиальной и решается в рамках текущего вызова.

Выполнение:

````shell
>python hanoi.py
(1, 3)
(1, 2)
(3, 2)
(1, 3)
(2, 1)
(2, 3)
(1, 3)
````

----------------------------------------------------------------------------------------------------
# Форматирование строк

Дано: переменная х содержащая числовое значение. Требуется составить строку "х = ...", где 
многоточие, это значение числа х.

````shell
>>> mcg = 'x = ' + str(x)
>>> mcg
'x = 12.5'
````

В языке Python  можно решить задачу проще, используя форматированные строки или это можно назвать 
интерполяцией строк. Буква `f` перед кавычкой указывает на то, что строка будет форматированной.

````shell
>>> mcg = f'x = {x}'
>>> mcg
'x = 12.5'
````

Без буквы `f`, строка воспринимается буквально.

````shell
>>> mcg = 'x = {x}'
>>> mcg
'x = {x}'
````

Преимущества:

- проще понять, как будет выглядеть результат;
- вставляемое в фигурных скобках выражение автоматически приводится к строковому типу. Внутри {}
можно указать параметры вывода. Более подробно смотри
[здесь](https://metanit.com/python/tutorial/5.3.php)

----------------------------------------------------------------------------------------------------
# Простой метод формирования коллекций

<!--i ["формирование коллекций"]-->
Традиционным способом формирования коллекции является следующая последовательность действий.

1. Создать пустую коллекцию.
1. Последовательно добавить в нее необходимые элементы.
1. Вернуть полученную   коллекцию. 

В ряде случаев можно использовать сокращенный вариант на основе имеющихся итерируемых объектов ---
[list comprehension](<!--page python_program_elements-->#collection_comprehension)
