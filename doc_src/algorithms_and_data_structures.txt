<!--VARIABLES {"title": "Алгоритмы и структуры данных", "SORT_ORDER": "20", 
"code": "algorithms_and_data_structures.txt"}-->

[TOC]

----------------------------------------------------------------------------------------------------
<!--i ["Алгоритмы и структуры данных"]-->
# Введение

Рассмотренная нами [модель вычислительного устройства](<!--page architecture-->#architecture) 
описывает две основные функциональные сущности: 

- память как "одномерное" адресное пространство;
- последовательность достаточно примитивных операций над содержимым этой памяти.

Все многообразие решаемых задач современной вычислительной техникой, в конечном счете сводится к 
манипуляции этими двумя сущностями. Однако оперировать такими **низкоуровневыми** категориями очень 
трудозатратно, а решение некоторых задач на таком уровне по своей сложности может превзойти 
способности программиста. 

Для человека более удобным и эффективным является манипулирование более высокоуровневыми категориями
уже известными из математики, естественных наук и жизненного опыта. Современные языковые и технические 
средства
позволяют такую манипуляцию. А раздел компьютерной науки, изучающий  эти категории, называется 
"Алгоритмы и структуры данных". Этот раздел изучает:

- различные способы организации и представления данных, их характеристики с точки зрения выполнения 
  различных операций над данными; 
- вычислительные методы и оценку их эффективности.

Эти знания  позволяют выбирать наиболее подходящие алгоритмы и структуры данных для конкретных задач,
а также создавать новые при отсутствии готовых решений.

----------------------------------------------------------------------------------------------------
<!--i ["эффективность алгоритма", "асимптотика"]-->
# Эффективность алгоритма

Вычислительные алгоритмы могут быть:

- реализованы на различных языках программирования, 
- переведены в машинный код с использованием различных трансляторов
- и выполнены на вычислительных устройствах различных архитектуры и мощности.

Поэтому мы не можем оценить эффективность алгоритма основываясь на физических показателях, таких
как время работы, потребление электроэнергии, повышение температуры. На различных языках, 
трансляторах и устройствах эти показатели могут очень сильно отличаться для одного и того же 
алгоритма при одних и тех же входных данных. В компьютерной науке для оценки эффективности алгоритма
используются относительные показатели характеризующие сам алгоритм и не учитывающие особенности его
реализации и исполнения. В основе данного подхода лежит 
[Теория сложности вычислений](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9).

Рассмотрим простой пример алгоритма сортировки, который получает на входе массив значений и должен
по окончанию работы оставить данный массив отсортированным. Основой для определения эффективности
будем считать размер массива *М* и попробуем рассмотреть эффективность различных алгоритмов 
используя только известное *М*.

Основными действиями при сортировке являются сравнения и перестановки. Для упрощения будем 
рассматривать только сравнение. Существуют методики позволяющие определить для конкретного 
алгоритма общее количество сравнений в зависимости *М*. Мы эти методики рассматривать  не будем,
а рассмотрим возможные результаты расчета. Предположим, есть два алгоритма которые совершают
количество перестановок равное соответственно:

-  *N*<sup>2</sup>
-  *N*<sup>3</sup>

Данные характеристики можно проиллюстрировать следующим образом. При сортировке массива из 10 
элементов  первый алгоритм выполнит 100 сравнений, а второй 1000. На основании имеющихся оценок
можно сделать вывод, что первый алгоритм работает эффективней. 

Для демонстрации рассмотрим два процессора: 

- Intel 8080 с частотой 10 МГц;
- современный процессор с частотой 3 ГГц.

Мощность второго в 300 раз выше.

Сортировка 1000 элементов первым алгоритмом будет выполнена в 1000<sup>3</sup> / 1000<sup>2</sup> 
= 1000 раз быстрее на одной и той же системе. Однако первый алгоритм на более слабом процессоре отработает
примерно в 3 раза быстрее, чем второй алгоритм на втором процессоре. За единицу вычислительной работы
мы приняли одно сравнение считая что все остальные операции сопутствующие сравнению занимают 
одинаковое время. Поэтому общее время работы наших алгоритмов можно представить как соответствие:

- *С*<sub>1</sub> * *N*<sup>2</sup>
- *С*<sub>2</sub> * *N*<sup>3</sup>

<!--i ["асимптотика", "О большое", "вычислительная сложность"]-->
где *С1* и *С2* постоянный коэффициенты, которые в данном случае равны времени выполнения одного 
сравнения и всех сопутствующих ему операций. Данные коэффициенты зависят от особенностей реализация 
исполнения, поэтому в оценке производительности алгоритмов отбрасываются формируя выражения называемое
*асимптотикой*. Для наших двух алгоритмов  асимптотики записываются соответственно так:

- *О* (*N*<sup>2</sup>) и
- *О* (*N*<sup>3</sup>).

Читается как "о большое от эн в квадрате/кубе".

!!! note
    Данная нотация выражает "оценку сверху", т.е. асимптотику времени работы алгоритма в худшем
    случае. Например (квадратичный) алгоритм пузырьковой сортировки, в худшем случае работает за 
    время *О*(*N*<sup>2</sup>). Однако, если на вход поступит уже отсортированный массив, то
    алгоритм отработает за время *О*(*N*).
    
К основным вычислительным ресурсам относятся:

- количество выполненных процессором операций (было рассмотрено выше). Эту характеристику еще 
    называют *вычислительной сложностью*;
- потребление памяти.

Вычислительные сложности типичных алгоритмов:

- поиск в не отсортированном списке --- *О*(*N*);
- поиск в отсортированном списке --- *О*(log *N*) (логарифмическая вычислительная сложность);
- удаление элемента списка *О*(*N*), потому что все последующие элементы мы должны сдвинуть;
- поиск в словаре по ключу *О*(1) (время *константно*);
- добавление и удаление ключа словаря *О*(1);
- операции с множествами: поиск, добавление, удаление *О*(1);
- эффективные, реально используемые сортировки --- *О*(*N* * log *N*).

Для демонстрации вариантов потребления памяти рассмотрим простую задачу: на вход алгоритму поступает 
*n* чисел, требуется принять их все и по завершению вернуть пять самых больших.

Заманчивым решением выглядит помещение всех полученных чисел в массив, сортировка массива по 
убыванию и возврат первых пяти элементов. Однако в этом случае потребление памяти составит 
*с* * *n*, где *с* это размер одного элемента массива. Асимптотику потребления памяти можно описать 
как  *О*(*N*). При больших *n*  возможно значительное 
потребление памяти вплоть до полного ее исчерпания. В тоже время возможно другое решение при котором 
в памяти находится не более шести элементов. При поступлении очередного числа оно добавляется 
к данным пяти элементам и среди них удаляется наименьшее. Данный алгоритм несколько сложнее 
реализовать однако его потребление памяти *константно*, т.е. не зависит от *n*.

----------------------------------------------------------------------------------------------------
<!--i ["рекурсия"]--><a name="recursion"></a>
# Рекурсия

Рекурсия такой прием программирования, при котором функция вызывает сама себя. Рассмотрим наиболее 
известный пример рекурсии в задаче [Ханойские башни](
https://ru.wikipedia.org/wiki/%D0%A5%D0%B0%D0%BD%D0%BE%D0%B9%D1%81%D0%BA%D0%B0%D1%8F_%D0%B1%D0%B0%D1%88%D0%BD%D1%8F).

````code
def hanoi(n, s1, s2, s3):
    if n < 1:
        return
    elif n < 2:
        yield s1, s3
    else:
        yield from hanoi(n-1, s1, s3, s2) # разворачивает генератор как for и возвращает значение
        yield s1, s3
        yield from hanoi(n-1, s2, s1, s3)
        
for i in hanoi(3, 1, 2, 3):
    print(i)        
````

В задаче требуется переложить *n* дисков  с одного стержня *s1* на другой *s3* используя оставшийся 
стержень *s2*. При решении данной задачи мы предполагаем что задача по перекладыванию *n-1* дисков
уже решена. Следовательно мы можем переложить *n-1* дисков со стержня *s1* на стержень *s2*, 
затем переложить 1 диск со стержня *s1* на стержень *s3* (что тривиально), а затем снова переложить
*n-1* дисков со стержня *s2* на стержень *s3*.

Для перекладывания *n-1* дисков мы можем вызвать ту же самую функцию `hanoi`, однако здесь есть
особенности. Во-первых, рекурсивный вызов должен происходить с уменьшением размера подзадачи. 
В данном случае уменьшение происходит на один диск (*n-1*). Во-вторых, рекурсивный вызов должен 
происходить до некоторого крайнего случая. В нашем примере когда *n* достигает значения 1, 
задача становится тривиальной и решается в рамках текущего вызова.

Выполнение:

````shell
>python hanoi.py
(1, 3)
(1, 2)
(3, 2)
(1, 3)
(2, 1)
(2, 3)
(1, 3)
````

----------------------------------------------------------------------------------------------------
<!--i ["сортировка слиянием", "merge sort"]-->
# Сортировка слиянием

<p><img src="<!--path pict-->merge_sort.png" class="floatRight" /></p>

Сортировка слиянием ([Википедия](
https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC))
выполняется следующим образом:

1. Дан не отсортированный список.
2. Список делится на две максимально равные части.
3. Каждая часть списка сортируется отдельно.
4. Отсортированные части сливаются в общий список.

Все промежуточные сортировки выполняются с использованием того же самого алгоритма, т.е. весь
алгоритм является [рекурсивным](#recursion). В процессе "рекурсивного спуска" размер сортируемого
списка уменьшается до тех пор пока не достигнет значения 0 или 1, т.е. крайнего случая, при котором 
сортировка становится тривиальной.

<p style="clear: both;"></p>

Полный текст программы находится в файле [`merge_sort.py`](<!--path code-->merge_sort/merge_sort.py).
Рассмотрим функции по отдельности. 

````code
def merge_sort(a):
    merge_sort_part(a, 0, len(a))
````

Функция `merge_sort` предназначена для вызова пользователем. Она вызывает основную рабочую функцию, 
передавая ей явно начальную и конечную границы входного списка.

````code
def merge_sort_part(a, left, right):
    if right - left > 1:
        middle = (right + left) // 2
        merge_sort_part(a, left, middle)
        merge_sort_part(a, middle, right)
        a[left:right] = merge(a, left, middle, right)
````

Функция `merge_sort_part` (как это следует из названия) фактически выполняет все перечисленные выше 
действия сортировки для фрагмента входного списка, кроме слияния, которое делегируется отдельной 
функции.

````code
def merge(a, left, middle, right):
    tmp = []
    i1 = left
    i2 = middle
    while i1 < middle and i2 < right:
        if a[i2] < a[i1]:
            tmp.append(a[i2])
            i2 += 1
        else:
            tmp.append(a[i1])
            i1 += 1
    for i in range(i1, middle):
        tmp.append(a[i])
    for i in range(i2, right):
        tmp.append(a[i])
    return tmp
````     

Функция `merge` сливает два смежных отсортированных фрагмента списка. К сожалению выполнить такое 
слияние на месте не получается без ухудшения асимптотики, поэтому расходуется дополнительная память
для формирования промежуточного результата. 

Тестирование показанных функций выполнено в файле 
[`merge_sort_test.py`](<!--path code-->merge_sort/merge_sort_test.py).




