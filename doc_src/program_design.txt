<!--VARIABLES {"title": "Проектирование программ", "SORT_ORDER": "09", "code": "program_design"}-->

[TOC]

----------------------------------------------------------------------------------------------------
# Задачи проектирования

<!--i ["проектирование", "интерфейс, программный", "декомпозиции", "моделирование"]--> 
В процессе **проектирования** программы определяются основные потребительские свойства этой 
программы(*интерфейс*), а также в общем виде структурные элементы и способы реализации 
(*моделирование* и *декомпозиция*).

## Интерфейс

**Интерфейс** определяет способ взаимодействия с программой. Например, это может быть веб-страница 
или консольное приложение. Интерфейс определяет какие данные пользователь вводит в программу, а 
какие получает в качестве результатов, а также определяет способы управления программой. 

Для [*функции*](<!--page python_program_elements-->#function), которая определена в программном коде 
и является частью программы, интерфейсом 
является набор принимаемых аргументов и тип возвращаемого значения. Интерфейс функции определяет 
способ взаимодействия этой функции с другим программным кодом. 

Интерфейс не определяет способ реализации функционала программы.

## Моделирование

**Модель** --- это такое представление объекта реального мира, которое содержит минимальное количество 
его характеристик, необходимое для решения поставленной задачи. Например: для библиотеки читатель 
представляется как сущность имеющая атрибуты ФИО, адрес, паспортные данные. Такие характеристики как
семейное положение и привычки не требуются.

## Декомпозиция

**Декомпозиция** --- это способ управления сложностью задачи, при котором задача разбивается на подзадачи,
которые в свою очередь могут также разбиваться образуя иерархию. Декомпозицию стоит выполнять для 
задач, которые сложно понять и решить без разбиения. Подзадачи следует стараться выделять 
максимально логически завершенными с минимальной зависимостью от остальных задач. В этом случае
возможно найти уже существующие решения, либо созданное решение может быть в последствии 
использовано в других задачах. 

----------------------------------------------------------------------------------------------------
<a name="test_hanoi"></a>
# Пример проектирования

Дана функция [`hanoi`](<!--page 4_python_drill-->#hanoi), которая возвращает последовательность 
перекладывания Ханойской башни. 

**Задача:** протестировать эту функцию.

## Интерфейс

Функцию тестирования назовем `test_hanoi`. Она будет принимать те же аргументы (`n, s1, s3, s2`), 
что и функция `hanoi`и  проверять работу функции `hanoi` с заданными аргументами. При положительном 
результате (функция `hanoi` работает корректно), функция `test_hanoi` ничего не выводит. В противном 
случае выводит сообщение об ошибке, включающее перечисление аргументов и описание некорректного 
поведения.


## Моделирование 

Проверку будем осуществлять посредством эмуляции перекладывания дисков реальных Ханойских башен.
Стержни будут представлены массивами, а диски элементами массивов. Диск у основания
пирамиды будет представлен элементом массива по индексу 0.

Перекладывание будет смоделировано извлечением (удалением) последнего элемента одного массива
и добавлением этого элемента в конец другого массива. 

Упомянутые выше массивы удобно расположить в массиве из трех элементов (`[[], [], []]`) и обращаться 
к ним по индексу. Для этих целей введём требование, что аргументы `s1, s2, s3` могут принимать 
значения 0, 1 или 2. 

!!! note "Замечание"
    Последнее соображение на самом деле к моделированию не относится, а относится к реализации.
    Здесь приведено для удобства последующего описания декомпозиции.
    

## Декомпозиция

Весь процесс реализации удобно разделить на следующие подзадачи:

1. Собираем проверочный стенд.

    Заполняем массив с индексом `s1` числами от `n` до 1 и в убывающем порядке.

1. Проверяем процесс перекладывания. 

    Предполагаемый алгоритм. Вызываем функцию `hanoi`, получаем от нее последовательность 
    перекладываний, выполняем 
    перекладывания и на каждом шаге проверяем, что добавляемый элемент меньше предыдущего, либо 
    является единственным элементом массива, если это не так, то выводим сообщение об ошибке и 
    завершаем проверку.
    
1. Проверяем конечное состояние. 

    По окончании перекладываний проверим, что в массиве с индексом `s3` 
    находится `n` элементов, а два других массива пусты.
   
Реализация теста представлена [здесь](<!--page 4_python_drill-->#hanoi).

-----------------------------------------------------------------------------------------------------
<!--i ["объектно-ориентированное программирование", "ООП", "object oriented programming", "ООР"]--> 
# Объектно-ориентированное программирование

Википедия:
[Объектно-ориентированное программирование, (*англ.*) Object Oriented Programming (ООР)](
https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5):

> Объе́ктно-ориенти́рованное программи́рование (сокр. *ООП*) — методология программирования, основанная 
> на представлении программы в виде совокупности взаимодействующих объектов, каждый из которых 
> является экземпляром определённого класса, а классы образуют иерархию наследования.

Технические детали создания объектов и классов представлены в разделе 
["Объекты и классы"](<!--page python_program_elements-->#objects_and_classes). Здесь будут 
рассмотрены более теоретические вопросы. 

*Типы данных* в различных языках используются для определения способа интерпретации значений.
Например: имея ссылку на целое число, транслятор языка руководствуясь описанием типов, принимает 
решение сколько ячеек памяти следует прочитать и каким образом выполнять операции с этим значением.

**Классы** можно представить как типы данные созданные программистом. Так же как с другими типами для
использования класса требуется создать соответствующие значения, **экземпляры** класса. 

Механизм **наследования** классов в какой-то степени аналогичен наследованию признаков живых существ
от родителей к потомкам в природе. В случае с классами дочерний класс обретает (наследует) все или
часть полей и методов родительского класса.

<!--i ["интерфейс, OOП"]--> 
Особенностью языка Python является отсутствие требования соответствия объекта определенному типу 
(классу). В более строгих языках программирования принадлежность объектов определенному классу 
определяет возможность его использования в конкретной ситуации, несмотря на это в языке  Python
является очень важной идея *интерфейса*. **Интерфейс** определяет поведение реализующих его объектов,
однако сам это поведение не реализует. Рассмотрим интерфейс [итерируемого объекта](
<!--page python_program_elements-->#iterable_objects), который может включать два метода:

- сообщить о наличии следующего элемента;
- вернуть следующий элемент.

<a name="iterable_objects"></a>
Данный интерфейс может быть реализован различными объектами например, *коллекциями* и *генераторами*.
Цикл `for` принимает итерируемый объект, который реализует перечисленные выше методы, следовательно
цикл `for` может работать одинаковым образом с различными объектами, если они реализуют
требуемый интерфейс.

!!! Note
    На самом деле сообщение об отсутствии следующего элемента происходит с использованием 
    [механизма исключений](<!--page python_program_elements-->#exceptions). Но в контексте данного 
    повествования эта особенность не существенна.
    
Один объект может реализовывать более одного интерфейса, например рассмотрим *списки* и *словари*. Для
доступа к элементам этих коллекций используются квадратные скобки, то же самое можно делать и со 
строками. Поддержка такого способа доступа также является реализацией интерфейса (subscriptable). 
Объекты не реализующие этот интерфейс (например, число) такой способ доступа не поддерживают. 

````shell
>>> n=5
>>> n[0]
TypeError: 'int' object is not subscriptable
````

----------------------------------------------------------------------------------------------------
<!--i ["эффективность алгоритма", "асимптотика"]-->
# Эффективность алгоритма

Вычислительные алгоритмы могут быть реализованы на различных языках программирования? переведены в 
машинный код с использованием различных трансляторов и выполнены на вычислительных устройствах
различных архитектуры и мощности.

Могут быть:

- реализованы;

- переведены;

- выполнены.

Поэтому мы не можем оценить эффективность алгоритма основываясь на физических показателях, таких
как время работы, потребление электроэнергии, повышение температуры. На различных языках, 
трансляторах и устройствах эти показатели могут очень сильно отличаться для одного и того же 
алгоритма при одних и тех же входных данных. В компьютерной науке для оценки эффективности алгоритма
используются относительные показатели характеризующие сам алгоритм и не учитывающие особенности его
реализации и исполнения. В основе данного подхода лежит 
[Теория сложности вычислений](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9).

Рассмотрим простой пример алгоритма сортировки, который получает на входе массив значений и должен
по окончанию работы оставить данный массив отсортированным. Основой для определения эффективности
будем считать размер массива **М** и попробуем рассмотреть эффективность различных алгоритмов 
используя только известное *М*.

Основными действиями при сортировке являются сравнения и перестановки. Для упрощения будем 
рассматривать только сравнение. Существуют методики позволяющие определить для конкретного 
алгоритма общее количество сравнений в зависимости *М*. Мы эти методики рассматривать  не будем,
а рассмотрим возможные результаты расчета. Предположим, есть два алгоритма которые совершают
количество перестановок равное соответственно:

-  *N*<sup>2</sup>

-  *N*<sup>3</sup>

Данные характеристики можно проиллюстрировать следующим образом. При сортировке массива из 10 
элементов  первый алгоритм выполнит 100 сравнений, а второй 1000. На основании имеющихся оценок
можно сделать вывод, что первый алгоритм работает эффективней. 

Для демонстрации рассмотрим два процессора: 

- Intel 8080 с частотой 10 МБц

- современный процессор с частотой 3 ГГц

Мощность второго в 300 раз выше.

Сортировка 1000 элементов первым алгоритмом будет выполнена в 1000<sup>3</sup> / 1000<sup>2</sup> 
= 1000 раз быстрее на одной и той же системе. Однако первый алгоритм на более слабом процессоре отработает
примерно в 3 раза быстрее, чем второй алгоритм на втором процессоре. За единицу вычислительной работы
мы приняли одно сравнение считая что все остальные операции сопутствующие сравнению занимают 
одинаковое время. Поэтому общее время работы наших алгоритмов можно представить как соответствие:

- *С*<sub>1</sub> * *N*<sup>2</sup>

- *С*<sub>2</sub> * *N*<sup>3</sup>

<!--i ["асимптотика", "О большое", "вычислительная сложность"]-->
где *С1* и *С2* постоянный коэффициенты, которые в данном случае равны времени выполнения одного 
сравнения и всех сопутствующих ему операций. Данные коэффициенты зависят от особенностей реализация 
исполнения, поэтому в оценке производительности алгоритмов отбрасываются формируя выражения называемое
*асимптотикой*. Для наших двух алгоритмов  асимптотики записываются соответственно так:

- *О* (*N*<sup>2</sup>) и

- *О* (*N*<sup>3</sup>).

Читается как "О" большое от *N* в квадрате/в кубе.

!!! note
    Данная нотация выражает "оценку сверху", т. е. асимптотику времени работы алгоритма в худшем
    случае. Например (квадратичный) алгоритм пузырьковой сортировки , в худшем случае работает за 
    время *О* от *N*<sup>2</sup>. Однако, если на вход поступит уже отсортированный массив, то
    алгоритм отработает за время *О* от *N*.
    
К основным вычислительным ресурсам относятся:

- количество выполненных процессором операций (было рассмотрено выше). Эту характеристику еще 
называют *вычислительной сложностью*.

- потребление памяти.

Вычислительные сложности типичных алгоритмов:

- поиск в не отсортированном списке --- *О*(*N*).

- поиск в отсортированном списке --- *О*(log *N*) (логарифмическая вычислительная сложность).

- Удаление элемента списка *О*(*N*), потому что все последующие элементы мы должны сдвинуть.

- Поиск в словаре по ключу *О*(*1*) (время *константно*).

- Добавление и удаление ключа словаря *О*(*1*).

Операции с множествами: поиск, добавление, удаление *О*(*1*).

Для демонстрации вариантов потребления памяти рассмотрим простую задачу: на вход алгоритму поступает 
*n* чисел, требуется принять их все и по завершению вернуть пять самых больших.

Заманчивым решением выглядит помещение всех полученных чисел в массив, сортировка массива по 
убыванию и возврат первых пяти элементов. Однако в этом случае потребление памяти составит 
*с* * *n*, где *с* это размер одного элемента массива. Асимптотику потребления памяти можно описать 
как  *О*(*N*). При больших *n*  возможно значительное 
потребление памяти вплоть до полного ее исчерпания. В тоже время возможно другое решение при котором 
в памяти находится не более шести элементов. При поступлении очередного числа оно добавляется 
к данным пяти элементам и среди них удаляется наименьшее. Данный алгоритм несколько сложнее 
реализовать однако его потребление памяти *константно*, т.е. не зависит от *n*.











