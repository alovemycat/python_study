<!DOCTYPE html>
<html>
<head><title>Элементы программы на языке Python</title>
<meta charset="utf-8">
<link rel="shortcut icon" type="image/png" href="../pict/favicon.png"/>
<link rel="stylesheet" type="text/css" href="../layout/styles.css"/>
<link rel="stylesheet" type="text/css" href="../layout/layout.css"/>
<link rel="stylesheet" type="text/css" href="../theme.css"/>

<style>
.headerNavArrows {position: relative; top: 3px;}
</style>
</head>
<body>

<div class="header"><b><span style="color:#59f;margin-right:7px;">Py</span></b><a 
class="header_item" href="index_page.html">Index</a><a 
class="header_item" href="todo_page.html">TODO</a><a 
class="header_item" href="problems_page.html">Задачи</a>

<a href="../../doc_src/python_program_elements.txt " class="header_item_source" title="Source text">&lt;/&gt;</a>


<a href="python_working_environment.html" title="Previous: Рабочая среда Python"><img class="headerNavArrows" src="../layout/pict/previous_page_h18px.png"/></a>

<a href="programming_techniques.html" title="Next: Приемы программирования"><img class="headerNavArrows" src="../layout/pict/next_page_h18px.png"/></a>


<span class="headerTitle">Элементы программы на языке Python</span>

</div>

<div class="sidebar">
    <table class="sidebarAligner">
        <tr><td valign="top">
            <div class="sidebar_item"><a href="about.html">Введение</a></div>
<div class="sidebar_item"><a href="architecture.html">Технические основы программирования</a></div>
<div class="sidebar_item"><a href="program_design.html">Проектирование программ</a></div>
<div class="sidebar_item"><a href="command_line_work.html">Работа в командной строке</a></div>
<div class="sidebar_item"><a href="related_technologies.html">Сопутствующие технологии</a></div>
<div class="sidebar_item"><a href="python_working_environment.html">Рабочая среда Python</a></div>
<div class="sidebar_item selected"><a href="python_program_elements.html">Элементы программы на языке Python</a></div>
<div class="sidebar_item"><a href="programming_techniques.html">Приемы программирования</a></div>
<div class="sidebar_item"><a href="algorithms_and_data_structures.html">Алгоритмы и структуры данных</a></div>
<div class="sidebar_item"><a href="technical_English.html">Technical English</a></div>
            <h3>Задачи</h3>
            <div class="sidebar_item"><a href="problems/01_12_intro.html">1 Основы</a></div>
<div class="sidebar_item"><a href="problems/2_lists .html">2 Циклы, строки, списки</a></div>
<div class="sidebar_item"><a href="problems/3_final_tasks.html">3 Итоговые задачи</a></div>
<div class="sidebar_item"><a href="problems/4_python_drill.html">4 Python drill</a></div>
<div class="sidebar_item"><a href="problems/5_chess.html">5 Шахматы</a></div>
            <h3>Useful links</h3>
            <div class="sidebar_item"><a href="https://www.python.org/">Python</a></div>
<div class="sidebar_item"><a href="https://git-scm.com/">Git</a></div>
        </td></tr>
        <tr><td class="bottom" valign="bottom">
            Generated by md2html_py 1.0.2
            <br />2023-02-18 18:34:32
        </td></tr>
    </table>
</div>

<p style="font-size:44px;font-weight:bold;margin:0 0 30px 0;">Элементы программы на языке Python</p>

<div class="toc">
<ul>
<li><a href="#_1">Комментарии</a></li>
<li><a href="#_2">Имена переменных</a></li>
<li><a href="#_3">Скалярные значения</a><ul>
<li><a href="#_4">Числовые значения</a></li>
<li><a href="#_5">Строки</a></li>
<li><a href="#_6">Логические значения</a></li>
<li><a href="#_7">Другие типы значений</a></li>
<li><a href="#_8">Определение типа значения</a></li>
</ul>
</li>
<li><a href="#_9">Операции</a></li>
<li><a href="#_10">Переменные</a></li>
<li><a href="#_11">Оператор приращения</a></li>
<li><a href="#_12">Выражения</a></li>
<li><a href="#_13">Ветвление</a></li>
<li><a href="#_14">Циклы</a><ul>
<li><a href="#_15">Цикл по условию</a></li>
<li><a href="#_16">Цикл по счетчику</a></li>
<li><a href="#else">Блок else</a></li>
<li><a href="#c">Циклы c предусловием и постусловием</a></li>
</ul>
</li>
<li><a href="#_17">Итерируемые объекты</a></li>
<li><a href="#_18">Функция</a></li>
<li><a href="#_19">Массив</a><ul>
<li><a href="#_20">Вложенные списки или матрицы</a></li>
<li><a href="#_21">Ссылочная модель вложенных списков</a></li>
</ul>
</li>
<li><a href="#_22">Кортеж</a></li>
<li><a href="#_23">Понятие скалярных и комплексных типов</a></li>
<li><a href="#_24">Словарь</a><ul>
<li><a href="#_25">Поиск по ключу</a></li>
<li><a href="#_26">Удаление элемента</a></li>
<li><a href="#_27">Добавление элемента</a></li>
<li><a href="#_28">Изменение элемента</a></li>
<li><a href="#_29">Итерация по словарю</a><ul>
<li><a href="#_30">По ключам</a></li>
<li><a href="#_31">По значениям</a></li>
<li><a href="#-">По парам ключ-значение</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_32">Модуль</a></li>
<li><a href="#_33">Объекты и классы</a></li>
<li><a href="#_34">Генерация коллекций</a></li>
<li><a href="#_35">Анонимный генератор</a></li>
<li><a href="#_36">Обработка ошибок</a></li>
<li><a href="#_37">Приведение значений к логическому типу</a></li>
<li><a href="#_38">Функции с переменным количеством аргументов</a></li>
<li><a href="#_39">Распаковка коллекций в аргументы при вызове функции</a></li>
<li><a href="#_40">Отступы</a></li>
<li><a href="#_41">Методы строк</a><ul>
<li><a href="#_42">Поиск и замена</a></li>
</ul>
</li>
</ul>
</div>
<hr />
<p><a name="index_entry_i_1"></a></p>
<h1 id="_1">Комментарии</h1>
<p>Комментарий начинается с символа <code>#</code>, они игнорируются интерпретатором и нужны для пояснения 
программистам или тем, кто читает код:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; print("Hello, world!")  # этот текст будет проигнорирован
Hello, world!</code></pre>
<hr />
<p><a name="index_entry_i_2"></a></p>
<h1 id="_2">Имена переменных</h1>
<p>Переменная может иметь короткое имя (например, <code>x</code> и <code>y</code>) или более описательное имя (<code>age</code>, 
<code>name</code>, <code>total_amount</code>).</p>
<p><strong>Правила для переменных Python</strong></p>
<ul>
<li>Имя переменной должно начинаться с буквы или символа подчеркивания.</li>
<li>Имя переменной не может начинаться с цифры.</li>
<li>Имя переменной может содержать только буквенно-цифровые символы и символы подчеркивания 
    (<code>A</code>-<code>z</code>, <code>0</code>-<code>9</code> и <code>_</code>).</li>
<li>Имена переменных чувствительны к регистру (<code>age</code>, <code>Age</code> и <code>AGE</code> — это три разные переменные).</li>
</ul>
<pre class="highlight"><code class="language-shell">myvar = "John"
my_var = "John"
_my_var = "John"
myVar = "John"
MYVAR = "John"
myvar2 = "John"</code></pre>
<p><strong>Использование переменных</strong></p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; name = 'Sasha'
&gt;&gt;&gt; print(name)
Sasha
&gt;&gt;&gt; print('Hello', name)
Hello Sasha</code></pre>
<hr />
<h1 id="_3">Скалярные значения</h1>
<p><a name="index_entry_i_3"></a>
<strong>Значение</strong> &mdash; это элемент данных, которым манипулирует программа. Любое значение каким то 
образом представлено в памяти. В программе они указываются непосредственно (в виде <em>литералов</em>) 
или появляются в результате вычисления (будет рассмотрено позже).</p>
<p>Далее будут рассмотрены различные типы значений.</p>
<p><a name="index_entry_i_4"></a></p>
<h2 id="_4">Числовые значения</h2>
<p><a name="index_entry_i_5"></a>
Примеры: <code>20</code>, <code>-5</code>, <code>2.5</code>, <code>2.5e2</code> (2,5 * 10<sup>2</sup> = 250).
В Python существует три числовых типа:</p>
<ul>
<li><code>int</code> &mdash; целые числа</li>
<li><code>float</code> &mdash; числа с плавающей точкой</li>
<li><code>complex</code> (специфический тип, сейчас рассматриваться не будет)</li>
</ul>
<p>Ввод числа с плавающей точкой:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; f = float(input())
12.5
&gt;&gt;&gt; print(f + 1)
13.5</code></pre>
<p>Преобразование типов чисел с помощью методов <code>int()</code>, <code>float()</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; x = 1         # int
&gt;&gt;&gt; y = 2.8       # float
&gt;&gt;&gt; a = float(x)  # convert from int to float
&gt;&gt;&gt; b = int(y)    # convert from float to int
&gt;&gt;&gt; print(a)
1.0
&gt;&gt;&gt; print(b)
2
&gt;&gt;&gt; print(type(a))
&lt;class 'float'&gt;
&gt;&gt;&gt; print(type(b))
&lt;class 'int'&gt;</code></pre>
<p><a name="index_entry_i_6"></a></p>
<h2 id="_5">Строки</h2>
<p>Примеры: <code>"a"</code>, <code>"b"</code>, <code>"23"</code>, <code>'A, "Z", s'</code>, <code>"A, 'Z', s"</code>. В строке могут использоваться 
специальные последовательности: </p>
<ul>
<li><code>\"</code>: <code>"Ф, П, \"р\", т"</code> &mdash; двойная кавычка внутри строки;</li>
<li><code>\'</code>: <code>'Ф, П, \'р\', т'</code> &mdash; одинарная кавычка внутри строки;</li>
<li><code>\\</code> &mdash; это один слеш;</li>
<li><code>\n</code> &mdash; это перевод строки.</li>
</ul>
<p>Присвоить строку переменной: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = "Hello"
&gt;&gt;&gt; print(a)
Hello</code></pre>
<p><strong>Перебор строки</strong></p>
<p>Поскольку строки являются массивами, мы можем перебирать символы в строке с помощью цикла <code>for</code>.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for x in "banana":
...     print(x)
...
b
a
n
a
n
a</code></pre>
<p>Функция <code>len()</code> возвращает <em>длину строки</em>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = "Hello, World!"
&gt;&gt;&gt; print(len(a))
13</code></pre>
<p><a name="index_entry_i_7"></a></p>
<h2 id="_6">Логические значения</h2>
<p>Имеются только два логических значения: <code>True</code> и <code>False</code>. </p>
<p><a name="bool_as_number"></a>
Логические значения в языке Python могут интерпретироваться как числа: <code>True</code> как 1, <code>False</code> как 0.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; True + True
2
&gt;&gt;&gt; True + False
1
&gt;&gt;&gt; False + False
0
&gt;&gt;&gt; s = [10, 20]
&gt;&gt;&gt; s[False]
10
&gt;&gt;&gt; s[True]
20</code></pre>
<h2 id="_7">Другие типы значений</h2>
<p>Есть другие типы значений, которые мы рассмотрим позже.</p>
<h2 id="_8">Определение типа значения</h2>
<p>Чтобы проверить тип любого объекта в Python, используется функция <code>type()</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; x = 1       # int
&gt;&gt;&gt; y = 2.8     # float
&gt;&gt;&gt; s = "demo"  # string
&gt;&gt;&gt; print(type(x))
&lt;class 'int'&gt;
&gt;&gt;&gt; print(type(y))
&lt;class 'float'&gt;
&gt;&gt;&gt; print(type(s))
&lt;class 'str'&gt;</code></pre>
<hr />
<h1 id="_9">Операции</h1>
<p><a name="index_entry_i_8"></a>
<strong>Операции</strong> нужны для выполнения <em>действий</em> над значениями: </p>
<ul>
<li>арифметические:<ul>
<li>простые <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>;</li>
<li>более сложные: <code>//</code> &mdash; деление нацело, <code>%</code> &mdash; остаток от деления.</li>
</ul>
</li>
<li>конкатенация (соединение) строк, например: <code>"А" + "В"</code> даст в результате <code>"AB"</code>; </li>
<li>повторение строк, например: <code>'a' * 5</code> даст <code>'aaaaa'</code>;</li>
<li>сравнение: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, 
    например: <code>1 &gt;= 2</code> даст <code>False</code>, <code>"А" == 'A'</code>даст <code>True</code>. </li>
<li>
<p>логические: <code>and</code>, <code>or</code>, <code>not</code>, например:</p>
<table>
<thead>
<tr>
<th>Выражение</th>
<th align="center">Вернет значение</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>True and True</code></td>
<td align="center"><code>True</code></td>
</tr>
<tr>
<td><code>True and False</code></td>
<td align="center"><code>False</code></td>
</tr>
<tr>
<td><code>False or True</code></td>
<td align="center"><code>True</code></td>
</tr>
<tr>
<td><code>not False</code></td>
<td align="center"><code>True</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>операция присвоения будет рассмотрена позже.</p>
</li>
</ul>
<p>Более подробно можно посмотреть <a href="https://www.w3schools.com/python/python_operators.asp">здесь</a>. </p>
<hr />
<h1 id="_10">Переменные</h1>
<p><a name="index_entry_i_9"></a>
Переменные &mdash; это ссылка на значение и могут использоваться также как и значения. Они могут 
участвовать в операциях.  Переменная имеет имя и указывается с использованием этого имени, например 
<code>a</code>, <code>dey_of_week</code>, <code>x1</code>. Переменным могут быть присвоены значения. Например, после выполнения 
операции <code>x = 5</code> использование x будет приравнено к использованию числа 5.</p>
<h1 id="_11">Оператор приращения</h1>
<pre class="highlight"><code class="language-code">а = 3  # переменной присваиваем значение 3
а += 4   # увеличиваем значение на 4
а = а + 4</code></pre>
<hr />
<h1 id="_12">Выражения</h1>
<p><a name="index_entry_i_10"></a>
<strong>Выражение</strong> &mdash; это конструкция состоящая из:</p>
<ul>
<li>значений;</li>
<li>переменных;</li>
<li>вызова функций (о них позже); </li>
<li>других выражений;</li>
<li>операций, которые служат для соединения других элементов. </li>
</ul>
<p>Пример выражения: <code>20 + Х - len(a)</code>.</p>
<p>Выражение в программе вычисляется и формируется <strong>значение</strong>, которое может быть присвоено переменной
либо участвовать в вычислении других выражений. Указатель значения либо переменной, так же является 
выражением. Например: <code>5</code>, <code>Х</code>, <code>"Х"</code>. </p>
<p><a name="index_entry_i_11"></a>
Значение которое заданно непосредственно без вычислений называется <strong>литералом</strong>. Например: <code>"аbc"</code>, 
<code>25.3</code>.</p>
<p>Выражение можно представить как иерархическую структуру, в которой одни элементы (выражения) 
включают другие. Рассмотрим пример: </p>
<pre class="highlight"><code class="language-code">max(2 + 2, len([0, 0] * 3))</code></pre>
<p><img src="../pict/expression.png" class="floatRight" /></p>

<p>На самом верхнем уровне выражение является вызовом функции <code>max</code> с двумя аргументами. Функция 
принимает аргументы в виде значений, следовательно, выражения, заданные в качестве аргументов,
должны быть предварительно вычислены. </p>
<p>Первый аргумент представляет собой операцию сложения двух значений, заданных литералами. Результатом
этой операции будет 4.</p>
<p>Второй аргумент предоставляет собой вызов функции <code>len</code> с аргументом, заданным выражением, 
которое, в свою очередь, представляет собой умножение списка (заданного литералом) на число (тоже
заданное литералом). Элементы списка так же заданны литералами. Результатом умножения будет список 
из шести нулей. Следовательно, функция <code>len</code> вернет 6.</p>
<p>В конечном счете функция <code>max</code> будет вызвана с аргументами 4 и 6 и вернет 6.</p>
<p style="clear: both;"></p>

<hr />
<h1 id="_13">Ветвление</h1>
<p><a name="index_entry_i_12"></a> 
<strong>Ветвление</strong> &mdash; это управляющая конструкция, которая позволяет выбрать последовательность операции в 
некоторой точке программы. Без управляющих конструкций операции выполняются в том порядке, в котором
они  представлены в программе. Последующие операции выбираются по <em>условию</em>, которое являются 
логическим  выражением. </p>
<pre class="highlight"><code class="language-code">t = 38
if t &lt; 37:  # оператор условия *if* со значением *t &lt; 37*
    print('здоров')  #  тело условия
else: # "альтернативная ветка" 
    print('болен')   </code></pre>
<p>Программа напечатает "болен".</p>
<hr />
<p><a name="index_entry_i_13"></a> </p>
<h1 id="_14">Циклы</h1>
<p><strong>Цикл</strong> &mdash; это управляющая конструкция, которая позволяет выполнять последовательность операций 
несколько раз. Два вида циклов: цикл по условию <code>while</code> и цикл по счетчику <code>for</code>. </p>
<p><a name="index_entry_i_14"></a> </p>
<h2 id="_15">Цикл по условию</h2>
<p>Тело цикла выполняется до тех пор, пока условие верно. </p>
<pre class="highlight"><code class="language-code">i = 3
while i &gt; 0:
    print(i)
    i = i - 1</code></pre>
<p>Программа выведет : 1, 2, 3.</p>
<p><a name="for_loop"></a><a name="index_entry_i_15"></a></p>
<h2 id="_16">Цикл по счетчику</h2>
<p>Цикл по счетчику выполняется по элементам итерируемого объекта. Итерируемым 
объектом может быть массив, из него можно последовательно получать (читать) элементы.</p>
<pre class="highlight"><code class="language-code">a = [1, 2, 3]
for x in a:
    print(x)</code></pre>
<p>Цикл <code>for</code> последовательно выбирает элементы списка <code>а</code> и присваивает их переменной <code>х</code>, которую 
можно использовать в теле цикла. Этот цикл можно назвать <em>синтаксический сахар</em>, потому что все тоже
самое можно сделать с помощью цикла <code>while</code>. </p>
<p>Список является <a href="#iterable_objects">итерируемым объектом</a>, поэтому его можно использовать в 
операторе <code>for</code>.</p>
<p><a name="index_entry_i_16"></a>
Другим  вариантом итерируемого объекта является <em>последовательность</em>. В математике ее могут называть
<em>прогрессией</em>. Функция <code>range()</code> является <em>генератором</em>, представляет арифметическую прогрессию и 
принимает аргументы:</p>
<ol>
<li>начальное значение (включительно);</li>
<li>конечное значение (не включительно);</li>
<li>приращение (шаг), по умолчанию +1.</li>
</ol>
<p>Если указать один аргумент, то последовательность будет от 0 до указанного числа с шагом +1.</p>
<pre class="highlight"><code class="language-code">for i in range(2, 8, 2):
    print(i)</code></pre>
<p>Данная программа напечатает 2, 4, 6.</p>
<pre class="highlight"><code class="language-code">for i in range(3):
    print(i)</code></pre>
<p>Данная программа напечатает 0, 1, 2.</p>
<p><a name="index_entry_i_17"></a></p>
<h2 id="else">Блок <code>else</code></h2>
<p>Также в циклах <code>while</code> и <code>for</code> можно указать <code>else</code>-блок после основного блока цикла. <code>else</code>-блок в 
циклах выполняется один раз после завершения работы цикла, но только в случае, если цикл не был прерван 
инструкцией <code>break</code>.</p>
<pre class="highlight"><code class="language-code">    n=input("Введите целое число, больше 1 ") # 1 Считали число n
     for d in range(2, n):                     # 2 d меняется от 2 до n-1
         if n % d == 0:                        # 3 Проверка: n делится на d?
             print n, "имеет делитель", d      # 4
             break                             # 5 Завершаем цикл for
     else:                                     # 6 Это else-блок цикла
         print n, "простое число"              # 7</code></pre>
<p><a name="index_entry_i_18"></a></p>
<h2 id="c">Циклы c предусловием и постусловием</h2>
<p>Циклы <code>for</code> и <code>while</code> являются циклами с предусловием, т.е. условие проверяется перед началом 
итерации и возможно такая ситуация, когда тело цикла не выполняется ни разу. 
(В случае с циклом <code>for</code> это происходит, если итерируемый объект пустой.) В цикле с постусловием 
условие проверяется по 
окончанию итерации и поэтому как минимум одна итерация будет выполнена. В языке нет специального
синтаксиса для циклов с постусловием. Однако они могут быть реализованы следующим образом.
Например есть задача: получать числа с клавиатуры и считать сумму положительных чисел, при вводе 
отрицательного  числа прекратить выполнение программы.</p>
<pre class="highlight"><code class="language-code">sum = 0
while True:
    a = int(input())
    if a &lt; 0:
        break
    sum += a
print(sum)</code></pre>
<p>Здесь постусловие относится к вводу числа с клавиатуры. Мы не знаем, что будет введено поэтому нам
нужно начать выполнение тела цикла в любом случае. Дальше принимается решение переходить или нет 
на следующую итерацию.</p>
<p>В цикле <em>for</em> указывается переменная и множество значений, по которому будет пробегать переменная.
Множество значений может быть задано <em>списком, кортежем, строкой или диапазоном</em>.
В списке значений могут быть выражения различных типов, например:</p>
<pre class="highlight"><code class="language-shell">for i in 1, 2, 3, 'one', 'two', 'three':
    print(i)</code></pre>
<hr />
<p><a name="index_entry_i_19"></a><a name="iterable_objects"></a></p>
<h1 id="_17">Итерируемые объекты</h1>
<p><strong>Итерируемые объекты</strong> &mdash; объекты позволяющие получать последовательность значений. К таким 
объектам относятся: </p>
<ul>
<li>списки;</li>
<li>словари;</li>
<li>множества;</li>
<li>кортежи;</li>
<li>строки, которые по факту являются списками символов;</li>
<li>генераторы.</li>
</ul>
<p><a href="program_design.html#iterable_objects">Итерируемые объекты</a> можно использовать в цикле <code>for</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i in {'a', 'b', 'c'}:
...     print(i)
...
a
c
b</code></pre>
<p><a name="index_entry_i_20"></a>
Функция <code>zip()</code> является интересным примером. Она принимает итерируемые объекты и возвращает
генеротор (который также являются итерируемым объектом). Пример:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i, j in zip(range(1, 4), ['яблоки', 'груши', 'сливы']):
...     print(i, j)
...
1 яблоки
2 груши
3 сливы</code></pre>
<p>В данном примере функция <code>zip()</code> принимает два итерируемых объекта, генератор и список, и 
возвращает последовательность пар элементов (кортеж). В цикле <code>for</code> данные значения присваиваются
переменным цикла <code>i</code> и <code>j</code>.</p>
<hr />
<h1 id="_18">Функция</h1>
<p><a name="index_entry_i_21"></a><a name="function"></a>
<strong>Функция</strong> в python - это объект, принимающий <em>аргументы</em> и возвращающий <em>значение</em>.
Функция обеспечивает <strong>инкапсуляцию</strong> программного кода, т.е. предоставляет единую точку входа
и избавляет пользователя функции от необходимости знать особенности ее реализации.
Обычно функция определяется с помощью инструкции <code>def</code>. Инструкция <code>return</code> говорит, что нужно 
вернуть значение. Чтобы вызвать функцию, используйте имя функции, за которым следуют круглые скобки. 
Термины <em>параметр</em> и <em>аргумент</em>  могут считаться синонимами обозначающими значения, которые
передаются в функцию.</p>
<pre class="highlight"><code class="language-shell">def bubble_sort(a):</code></pre>
<p>По умолчанию функция должна вызываться с правильным количеством аргументов. Это означает, что если 
ваша функция ожидает 2 аргумента, вы должны вызывать функцию с 2 аргументами, не больше и не меньше.
Если вы не знаете, сколько аргументов будет передано в вашу функцию, добавьте <code>*</code>перед именем 
параметра в определении функции. Аргументы приходят извне и внутри функции могут использоваться так 
же, как и локальные (внутри функции) переменные. Аргументы, которые передаются в функцию через 
запятую, называются <em>позиционными</em>. Существуют и <em>именнованные</em> параметры, которые имеют имена.
Например: 
<pre class="highlight"><code class="language-code">print (1, 'a', True, sep=',', end= '|')</code></pre></p>
<p>В данном примере в функцию <code>print</code> передаются три позиционных аргумента (<code>1</code>, <code>'a'</code>, <code>True</code>) и два
именнованных аргумента (<code>sep=','</code>, <code>end= '|'</code>), они указываются всегда после позиционных.</p>
<p><a name="index_entry_i_22"></a><a name="functions_first_class_objects"></a>
Особенности функций как объектов первого класса:</p>
<ul>
<li>Функции можно присваивать переменным.</li>
<li>Функция может быть примером объекта.</li>
<li>Функцию можно вернуть из функции.</li>
<li>У функций те же свойства и методы, что и у объектов.</li>
<li>Функцию можно передать в качестве аргумента при вызове другой функции.</li>
</ul>
<pre class="highlight"><code class="language-code">def print_field(string, transform):
    print('[' + transform(string) + ']')

def simple_transform(string):
    return string   # Что пришло, то функция и вернула

def password_transform(string):
    return '*' * len(string)  # Возвращает звездочки

print_field("I love my cat", simple_transform)
print_field("my secret", password_transform)</code></pre>
<p>Объяснение. Функция <code>print_field</code> принимает в качестве второго аргумента функцию, которую вызывает
внутри своего тела. При вызове функции <code>print_field</code> ей могут быть переданы различные функции с 
различным поведением. В данном примере будет выведено:</p>
<pre class="highlight"><code class="language-shell">[I love my cat]
[*********]</code></pre>
<p>Другой пример использования функции как объекта можно посмотреть
<a href="problems/4_python_drill.html#password_strength">здесь</a>.</p>
<p><a name="index_entry_i_23"></a><a name="lambda"></a>
В функцию <code>print_field</code> можно передавать анонимную функцию используя lambda-выражение. </p>
<pre class="highlight"><code class="language-code">print_field("I love my cat", lambda s: s)
print_field("my secret", lambda s: '*' * len(s))</code></pre>
<p>В данном случае lambda-выражение позволяет нам определить функцию на месте, т.е. в той точке кода, 
где требуется ее указать. По сравнению с предыдущим вариантом, дополнительных функций 
(<code>simple_transform</code> и <code>password_transform</code>) создавать не нужно. Результат выполнения будет такой 
же точно.</p>
<p>Другой пример использования lambda-выражений смотри
<a href="problems/3_final_tasks.html#coordinates_1">здесь</a>.</p>
<p><a name="index_entry_i_24"></a>
Функция может возвращать результат. Для этого в функции используется оператор <code>return</code>, после 
которого указывается возвращаемое значение:</p>
<pre class="highlight"><code class="language-code">1. def get_message():
1.   return "Hello METANIT.COM  # return возвращаемое значение.

message = get_message()  # получаем результат функции get_message в переменную message
print(message)          # Hello METANIT.COM

# можно напрямую передать результат функции get_message
print(get_message())    # Hello METANIT.COM</code></pre>
<p>Оператор return не только возвращает значение, но и производит выход из функции. Поэтому он должен 
определяться после остальных инструкций.</p>
<p><a name="index_entry_i_25"></a>
<strong><code>yield</code></strong> — это ключевое слово в Python, которое используется для возврата из функции с сохранением 
состояния ее локальных переменных, и при повторном вызове такой функции выполнение продолжается с 
оператора yield, на котором ее работа была прервана. Любая функция, содержащая ключевое слово yield,
называется генератором. Можно сказать, yield — это то, что делает ее генератором. Хотя оператор yield
в Python не отличается популярностью, но он имеет множество достоинств, о которых стоит знать.</p>
<p><pre class="highlight"><code class="language-code">def fibonacci(n):
    """функция-генератор возвращает последовательность Фибоначчи""" 
    f1 = -1
    f2 = 1
    for i in my_range(0, n, 1):
        f3 = f1 + f2 
        yield f3 
        f1 = f2
        f2 = f3</code></pre>
Преимущества <code>yield</code>:</p>
<p>Поскольку генераторы автоматически сохраняют и управляют состояниями своих локальных переменных, 
программист не должен заботиться о накладных расходах, связанных с выделением и освобождением памяти.
Так как при очередном вызове генератор возобновляет свою работу, а не начинает с самого начала, общее 
время выполнения сокращается.</p>
<p>Недостатки <code>yield</code>:</p>
<p>Иногда использование <code>yield</code> может вызвать ошибки, особенно если вызов функции не обрабатывается 
должным образом.
За оптимизацию времени работы и используемой памяти приходится платить сложностью кода, поэтому иногда
трудно сходу понять логику, лежащую в его основе.  </p>
<p><a name="index_entry_i_26"></a> 
Функция <code>input()</code> в Python временно приостанавливает выполнение программы и ожидает, пока 
пользователь введёт данные. Как только функция получает данные от пользователя, Python автоматически
 заносит их в переменную, чтобы с ними было удобно работать.
Функция input() получает только один аргумент и это текст подсказки, который выводится на экран,
чтобы пользователь понимал что от него требуется. </p>
<pre class="highlight"><code class="language-code">X = int(input())
Y = int(input())
print(X*60 + Y)
5
20
320</code></pre>
<p>Функция <code>input()</code> всегда возвращает строковое значение, даже числа возвращаются в виде строковых 
символов. Функция <code>int()</code> принимает текстовое представление целого числа и возвращает 
соответствующее число. Например: </p>
<pre class="highlight"><code class="language-code">&gt;&gt;&gt; print(int('0017'))
17</code></pre>
<p><a name="index_entry_i_27"></a>
Функция <code>sqrt()</code> – это встроенная функция, которая возвращает квадратный корень из любого числа.</p>
<pre class="highlight"><code class="language-code">a = int(input())
b = int(input()) 
c = int(input())
p = ((a + b + c) / 2)
s = (p * (p-a) * (p-b) * (p-c)) ** (1/2)
print(s)</code></pre>
<hr />
<h1 id="_19">Массив</h1>
<p><a name="index_entry_i_28"></a> 
<strong>Массив</strong> &mdash; это сложное (композитное) значение, состоящее из идущих подряд значений, 
которые называются <em>элементами массива</em>.</p>
<pre class="highlight"><code class="language-code">x = 10
a = [1, 'hi', 1 + 1, x] # В данном примере массив *а* содержит элементы: [`1`, `hi`, `2`, `10`]
</code></pre>
<p><a name="index_entry_i_29"></a> 
Элементы массива имеют порядковые номера, которые называются 
<em>индексами</em>. Индексы &mdash; это последовательные целые числа начинающиеся с нуля. Доступ к элементу
массива осуществляется по индексу следующим образом: выражение  <code>a[0]</code> вернет выражение <code>1</code>; после 
<code>операции</code> <code>a[2] = 2</code>, третий по порядку элемент массива будет являться 2.
Для массивов определена функция <code>len</code>, которая возвращает длину массива. Выражение <code>len(а)</code>вернет 
значение 4.</p>
<p>Массивы используют для предоставления набора значений количество которых заранее не известно. 
Рассмотренная структура, в языке Python, является не массивом, а списком, который в свою очередь 
является объектом (см. <a href="#objects_and_classes">ниже</a>). Данный объект обладает методами для манипуляции 
элементами массива или списка такими как, добавление, удаление, сортировка. </p>
<h2 id="_20">Вложенные списки или матрицы</h2>
<p><a name="index_entry_i_30"></a>
Вложеные списки &mdash; это когда в качестве элемента одного списка, являются другие списки. Если все 
вложенные списки имеют одинаковую длинну, то такой список может представлять прямоугольную таблицу 
или <em>матрицу</em>.</p>
<p>В языке программирования Питон таблицу можно представить в 
виде списка строк, каждый элемент которого является в свою очередь списком, например, чисел. 
Например, создать числовую таблицу из трёх строк и трех столбцов можно так:</p>
<div class="tableHederless"></div>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">-6</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">-1</td>
<td align="center">4</td>
<td align="center">9</td>
</tr>
</tbody>
</table>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; m = [[5, 2, 7], [3, -6, 8], [-1, 4, 9]]
&gt;&gt;&gt; m
[[5, 2, 7], [3, -6, 8], [-1, 4, 9]]</code></pre>
<p>Мы можем обратиться к любому элементу из этой матрицы по индексам <code>m[i][j]</code>.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; m[0]
[5, 2, 7]
&gt;&gt;&gt; m[0][0]
5
&gt;&gt;&gt; m[1]
[3, -6, 8]
&gt;&gt;&gt; m[2][1]
4</code></pre>
<p><a name="list_memory_model"></a></p>
<h2 id="_21">Ссылочная модель вложенных списков</h2>
<p>Пусть имеем вложенный список созданный следующим образом:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [[0] * 3]</code></pre>
<p>В памяти это будет выглядеть следующим образом (поз. 1):</p>
<p><img alt="" src="../pict/list_memory_model.png" /></p>
<p>Если мы хотим иметь три вложенных списка, то мы можем поступить следующим образом: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [[0] * 3] * 3</code></pre>
<p>При этом память будет выглядеть как на рисунке, поз. 2, т.е. элементы внешнего списка будут 
ссылаться на один и тот же список. При этом возможна следующая ситуация:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a[0][0] = 1
&gt;&gt;&gt; a
[[1, 0, 0], [1, 0, 0], [1, 0, 0]]</code></pre>
<p>Здесь был изменен первый вложенный список, но поскольку все вложенные списки это один и тот же 
список, то в результате список будет выглядеть так, как это видно из кода.</p>
<p><a name="index_entry_i_31"></a>
Чтобы создать действительно разные списки (как на рисунке в поз. 3) можно использовать средство 
генерации списков (<em>list comprehension</em>):</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [[0] * 3 for i in range(3)]
&gt;&gt;&gt; a[0][0] = 1
&gt;&gt;&gt; a
[[1, 0, 0], [0, 0, 0], [0, 0, 0]]</code></pre>
<hr />
<h1 id="_22">Кортеж</h1>
<p><a name="index_entry_i_32"></a>
<strong>Кортежи</strong> можно представить как неизменяемые массивы. Кортеж задается перечислением значений через 
запятую, при необходимости данные перечисления можно взять в скобки. Помимо прочего они позволяют 
<em>множественные присваивания</em>. Присваивание значений сразу нескольким переменным.  </p>
<pre class="highlight"><code class="language-code">def get_tuple():
    return 5, "с", True  # возвращает картеж из трех элементов разного типа.
    # функция заканчивает свою работу.

А, В, С = get_tuple()
print(А, В, С)</code></pre>
<hr />
<h1 id="_23">Понятие скалярных и комплексных типов</h1>
<p><strong>Скалярное</strong> значение, это некое неделимое значение, типа строка, число, логическое значение.
Типы таких значений, так же называют скалярными.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>На самом деле строка предполагает деление на символы, но в контексте данного описания мы 
можем этим пренебречь.</p>
</div>
<p><strong>Комплексное</strong> значение, это такое значение, которое содержит в себе другие значения.
Среди комплексных значений можно назвать:</p>
<p><a href="#classes">классы</a> Количество значений объекта (экземпляра класса) определяется структурой класса.
- коллекции</p>
<p><a name="index_entry_i_33"></a>
Коллекция &mdash; это <em>комплексное</em> значение, которое содержит  изначально неопределенное количество
других значений. К ним относятся:
- списки
- кортежи
- словари
- множества</p>
<hr />
<h1 id="_24">Словарь</h1>
<p><a name="index_entry_i_34"></a>
<strong>Словарь</strong> можно представить как набор <em>ключей</em> и соответствующих им значений. Например:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d={'dog': 'собака', 'cat': 'кот', 'human': 'человек'}
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кот', 'human': 'человек'}</code></pre>
<p>В этом примере мы создали словарь <code>d</code> с тремя элементами. Рассмотрим основные операции со словарями.</p>
<h2 id="_25">Поиск по ключу</h2>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d['cat']
'кот'
&gt;&gt;&gt; d['cow']
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 'cow'</code></pre>
<p>Поиск по ключу 'cat' вернул соответствующее значение, а поиск по ключу 'cow' вызвал ошибку, потому
что элемента с таким ключем в словаре нет. Возможен другой способ поиска, при котором для 
отсутствующего ключа возвращается пустое значение:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; print(d.get('cow'))
None</code></pre>
<h2 id="_26">Удаление элемента</h2>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; del d['human']
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кот'}</code></pre>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Если удаляемый ключ отсутствует, то операция удаления вызовет ошибку <code>KeyError</code> как в 
предыдущем примере.</p>
</div>
<h2 id="_27">Добавление элемента</h2>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d['cow'] = 'корова'
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кошка', 'cow': 'корова'}</code></pre>
<h2 id="_28">Изменение элемента</h2>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d['cat'] = 'кошка'
&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кошка', 'cow': 'корова'}</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Следует обратить на то, что синтаксис при изменении и добавлении элемента совпадает.
Если ключ уже существует, то соответствующее значение меняется, в противном случае добавляется 
новый элемент с заданным ключом.</p>
</div>
<p><a name="index_entry_i_35"></a>    </p>
<h2 id="_29">Итерация по словарю</h2>
<p>Имеется словарь <code>d</code>:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; d
{'dog': 'собака', 'cat': 'кошка', 'cow': 'корова'}</code></pre>
<p>Требуется выполнить с каждым элементом некоторые действия. Для простоты будем печатать ключи и 
значения. Существует три способа итерации.</p>
<p>Также см. <a href="#for_loop">цикл <code>for</code></a>.</p>
<h3 id="_30">По ключам</h3>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for k in d.keys():
...     print(k)
...
dog
cat
cow</code></pre>
<p>Метод <code>d.keys()</code> возвращает список ключей словаря <code>d</code> как итерируемый объект. Следовательно, этот
объект может быть использован в цикле <code>for</code>. На каждой итерации переменная цикла <code>k</code> получает 
значение очередного ключа.</p>
<p>Идентичным образом работает выражение <code>for k in d:</code>.</p>
<h3 id="_31">По значениям</h3>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for v in d.values():
...     print(v)
...
собака
кошка
корова</code></pre>
<h3 id="-">По парам ключ-значение</h3>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for k, v in d.items():
...     print(k, v)
...
dog собака
cat кошка
cow корова </code></pre>
<p>Метод <code>d.items()</code> возвращает список кортежей из двух элементов, ключа и значения. Поэтому 
используются две переменные цикла, <code>k</code> и <code>v</code>.</p>
<hr />
<h1 id="_32">Модуль</h1>
<p><strong>Модуль</strong> в <em>программировании</em> &mdash; это независимая и функционально законченная часть программы, 
оформленная в виде фрагмента кода и сохранена в отдельный <em>файл</em>. Чтобы использовать модуль в другой
программе мы его импортируем (import).</p>
<p>Более подробно смотри <a href="python_working_environment.html#library_installation">здесь</a>.</p>
<hr />
<h1 id="_33">Объекты и классы</h1>
<p><a name="index_entry_i_36"></a>   <a name="objects_and_classes"></a>
Простые, "примитивные" типы данных описывают одно значение. Объекты реального мира моделируемые в 
программе могут иметь несколько <em>атрибутов</em> различных типов. Например, книга в каталоге может быть 
описана следующими атрибутами:</p>
<ul>
<li>автор;</li>
<li>название;</li>
<li>год издания;</li>
<li>количество страниц.</li>
</ul>
<p><a name="index_entry_i_37"></a><a name="classes"></a>
<strong>Классы</strong>- это сложные (композитные) типы данных, которые позволяют определить несколько именованных 
значений внутри некоторой программной <em>сущности</em>. Так же внутри класса могут быть определены фукции,
которые манипулируют этими значениями. Например, 
следующий класс представляет сущность 
"Книга" описанную выше. </p>
<pre class="highlight"><code class="language-code">class Book:
    def __init__(self, author, title, year, page_count):  # функция __init__ это конструктор класса

    # при вызове метода объекта нам обязательно необходимо использовать слово self
    # для обращения к атрибутам объекта внутри класса в его методах также применяется слово self:
        self.author = author  # это одно из полей класса
        self.title = title
        self.year = year
        self.page_count = page_count

    def colofon(self):
        return (self.author + ' "' + self.title + '", ' + str(self.year) + ' г., ' +  
        str(self.page_count) + ' c.')</code></pre>
<p><a name="index_entry_i_38"></a><br />
Класс можно представить как шаблон, на основе которого создаются (инстанцируются) <strong>объекты</strong>, которые
иногда называются <em>экземплярами</em> класса. Пример:</p>
<pre class="highlight"><code class="language-code">book1 = Book('А. Блок', 'Ветер', 1975, 45) # выражение, создающее экземпляр класса Book
print(book1.author)
print(book1.title)
print(book1.colofon()) </code></pre>
<p>Программа выведет строки: "А. Блок", "Ветер".</p>
<hr />
<p><a name="index_entry_i_39"></a><a name="collection_comprehension"></a></p>
<h1 id="_34">Генерация коллекций</h1>
<p>Рассмотрим простой способ генерирования списка, например, квадратов чисел от 1 до 7:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; lst = []
&gt;&gt;&gt; for i in range(1, 8):
...     lst.append(i * i)
...
&gt;&gt;&gt; lst
[1, 4, 9, 16, 25, 36, 49]</code></pre>
<p>Способ рабочий, но достаточно многословный. Конструкция <strong>list comprehension</strong> позволяет сделать 
это в одну строку:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; lst = [i * i for i in range(1, 8)]
&gt;&gt;&gt; lst
[1, 4, 9, 16, 25, 36, 49]</code></pre>
<p>List comprehension работает подобно <a href="#for_loop">циклу <code>for</code></a>, только направляет значения переменной цикла 
в генерируемый список. Подобным способом можно генерировать другие виды коллекций.</p>
<p>Также в этой конструкции возможна фильтрация, например, используя созданный 
список, сгенерируем кортеж, в который  попадут только четные числа, деленные на 2:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; tuple(i // 2 for i in lst if i % 2 == 0)
(2, 8, 18)</code></pre>
<p>Теперь сгенерируем словарь используя тот же самый список, как набор ключей. Значениями будут 
являться двоичные представления этих чисел.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; {i: f"{i:b}" for i in lst}
{1: '1', 4: '100', 9: '1001', 16: '10000', 25: '11001', 36: '100100', 49: '110001'}</code></pre>
<p>Сгенерируем множество из некоторого произвольного списка.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; set(i for i in [2, 2, 1, 1, 3])
{1, 2, 3}</code></pre>
<p>Функция которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а 
чётные нацело делит на два. Можно для решения использовать <em>list comprehension</em>.</p>
<pre class="highlight"><code class="language-code">def modify_list(numbers):
    numbers[:] = [i//2 for i in numbers if i%2 == 0]</code></pre>
<hr />
<p><a name="index_entry_i_40"></a><a name="anonymous_generator"></a></p>
<h1 id="_35">Анонимный генератор</h1>
<p>Генерация коллекций (list comprehension) создает объект, который занимает какое-то место в памяти.
Потребление памяти составляет О(N).</p>
<p><pre class="highlight"><code class="language-shell">&gt;&gt;&gt; [i*2 for i in range(5)]
[0, 2, 4, 6, 8]</code></pre>
Если в этой конструкции указать круглые скобки вместо квадратных, то получится генератор, 
возвращающий рассчитанные элементы без помещения их в память.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; (i*2 for i in range(5))
&lt;generator object &lt;genexpr&gt; at 0x0000016E82F79BA0&gt;</code></pre>
<p>Полученный объект генератора является итерируемый объектом, который будет возвращать генерируемые 
элементы, не сохраняя их в памяти. </p>
<pre class="highlight"><code class="language-shell">g =(input() for _ in range(2))
&gt;&gt;&gt; g = (i*2 for i in range(5))
&gt;&gt;&gt; sum(g)
20</code></pre>
<p>Точно также можно было бы использовать list comprehension (с квадратными скобками), однако в этом
случае был бы создан список с умноженными на два числами от 0 до 4, который после подсчета суммы 
нам больше не требуется. При использовании генератора (с круглыми скобками) умножение на 2 
происходит "на лету", и полученные элементы нигде не накапливаются. Потребление памяти константно,
О(1).</p>
<p>Можно посчитать сколько цифр в строке.</p>
<pre class="highlight"><code class="language-code">print(sum(i.isdigit() for i in input()))</code></pre>
<p>В этом примере используется <a href="#bool_as_number">интерпретация логических значений как чисел</a>.</p>
<p>Пример использования можно также посмотреть и <a href="problems/4_python_drill.html#ip_address_check">здесь</a>.</p>
<p>Рассмотрим еще один пример. </p>
<p>В случае с list comprehension возвращается список, поэтому все действия (в том числе ввод с 
клавиатуры) выполняются до завершения формирования списка.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [input() for _ in range(2)]
a
b
&gt;&gt;&gt; a
['a', 'b']</code></pre>
<p>Для доказательства отложенной работы генератора рассмотрим следующий пример:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; g =(input() for _ in range(2))
&gt;&gt;&gt; </code></pre>
<p>Здесь мы создали анонимный генератор, который определяет отложенные действия. Как мы видим ввод
с клавиатуры не был запрошен. Это будет сделано во время использования данного генератора.</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for s in g: print('--&gt;', s)
...
a
--&gt; a
c
--&gt; c
&gt;&gt;&gt;</code></pre>
<hr />
<p><a name="index_entry_i_41"></a><a name="exceptions"></a> </p>
<h1 id="_36">Обработка ошибок</h1>
<p>Ошибки в программировании часто называют <strong>исключениями</strong>, <em>англ</em>.  <strong>exception</strong>.</p>
<p>При возникновении ошибки в программе, Python прекращает выполнение программы и отображает сообщение 
об ошибке. </p>
<pre class="highlight"><code class="language-code">x = 0
print(f 'x = {x}')  # (1)
y = 5 / x           # (2)
print(y)            # (3)</code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
x = 0
Traceback (most recent call last):
  File "hello.py", line 3, in &lt;module&gt;
    y = 5 / x
ZeroDivisionError: division by zero</code></pre>
<p>В нашем примере (строка 1) была выполнена, в (строке 2) произошла ошибка, поэтому остальная часть 
программы (строка 3) не была выполнена. В данном случае сообщение об ошибке было выведено в консоль.</p>
<p>В каких-то случаях такое поведение является логичным, поскольку ошибка является неожиданной и 
дальнейшее выполнение программы будет непредсказуемо. В нашем примере значение переменной <code>y</code> ,
после (строки 2) не определено, поэтому использование ее не возможно. Программист может обработать 
возможную ошибочную ситуацию, например так:</p>
<pre class="highlight"><code class="language-code">x = 0
print(f'x = {x}')   # (1)
if x == 0:
    y = 0
else:
    y = 5 / x          # (2)
print(f'y = {y}') </code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
x = 0
y = 0</code></pre>
<p>Такие решения должны быть тщательно продуманы и согласованы с бизнес-требованиями. Возможно, что в
подобной ситуации заказчик  ожидает, что программа аварийно завершит работу. Тогда данное 
решение приведет к <strong>сокрытию</strong> ошибки, которая может потом проявиться в других частях программы.
В языке Python есть специальный способ обработки ошибок.</p>
<pre class="highlight"><code class="language-code">x = 0
print(f'x = {x}')   # (1)
try: 
    y = 5 / x 
except ZeroDivisionError:
    y = 0       # (2)
print(f'y = {y}') </code></pre>
<pre class="highlight"><code class="language-shell">&gt;python hello.py
x = 0
y = 0</code></pre>
<p>Блок <code>try - except</code> (защищенный блок) определяет фрагмент программы, в котором ошибки не будут
сразу вызывать аварийное завершение всей программы. В блоке <code>except</code> есть возможность каким-то
образом устранить последствия ошибки и/или бросить тоже самое или другое исключение.</p>
<p>В данном примере указана конкретная ошибка <code>ZeroDivisionError</code>, которая будет "отлавливаться", 
если конкретную ошибку не указать, то будут отлавливаться все ошибки.</p>
<p>В следующей задаче вводится массив чисел и некоторое число <code>x</code>. Требуется вывести все индексы числа 
<code>x</code> в массиве. Если таковых нет, то вывести "None".</p>
<pre class="highlight"><code class="language-code">lst = [int(i) for i in input().split()]
x = int(input())
i = -1
while True:
    try:
        i = lst.index(x, i + 1)
    except:
        if i &lt; 0:
            print("None")
        break
    print(i, end=' ')</code></pre>
<p>Метод списка <code>index()</code> возвращает первый индекс заданного значения в массиве,
а если такого значения нет, то завершается исключением (ошибкой). В данном случае нам <strong>требуется</strong>
перехватывать исключения для корректного решения задачи. </p>
<hr />
<p><a name="index_entry_i_42"></a></p>
<h1 id="_37">Приведение значений к логическому типу</h1>
<p>Конструкции языка Python, требующие для своей работы логические выражения/значения, таки как
условия <code>if</code> и <code>while</code>, могут так же принимать выражения/значения других типов, которые 
интерпретируются как логические. Например: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; if 1+1:
...     print('yes')
yes</code></pre>
<p>Казалось бы. условному оператору требуется логический аргумент для принятия решения, однако в данном
мы видим, что в данном случае оператор <code>if</code> интерпретировал значение 2 как  <code>True</code>. Особенностью 
языка Python является то , что в нем значения разных типов могут приводиться к соответствующему
логическому значению. Основные правила таковы:</p>
<table>
<thead>
<tr>
<th>Тип</th>
<th>False</th>
<th>True</th>
</tr>
</thead>
<tbody>
<tr>
<td>число</td>
<td>0</td>
<td>все остальные</td>
</tr>
<tr>
<td>строка</td>
<td>пустая строка</td>
<td>не пустая строка</td>
</tr>
<tr>
<td>коллекция</td>
<td>пустая коллекция</td>
<td>не пустая коллекция</td>
</tr>
<tr>
<td>None</td>
<td>всегда</td>
<td>никогда</td>
</tr>
</tbody>
</table>
<p>По аналогии с функциями <code>int()</code> и <code>str()</code> есть функция <code>bool</code>, которая возвращает логическое 
представление значений различных типов. Рассмотрим примеры ее работы:</p>
<p><a name="index_entry_i_43"></a></p>
<table>
<thead>
<tr>
<th>Тип</th>
<th>Выражение</th>
<th>Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td>число</td>
<td><code>bool(0)</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>число</td>
<td><code>bool(0.0000001)</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>число</td>
<td><code>bool(-1)</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('')</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('a')</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('0')</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>строка</td>
<td><code>bool('False')</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>логический</td>
<td><code>bool([False])</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>список</td>
<td><code>bool([])</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>список</td>
<td><code>bool([5, 'a'])</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>словарь</td>
<td><code>bool({})</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>словарь</td>
<td><code>bool({1:'s'})</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>коллекция</td>
<td><code>bool({1:'s'})</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td>коллекция</td>
<td><code>bool(set())</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td>коллекция</td>
<td><code>bool(set([5,a]))</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>None</code></td>
<td><code>bool(None)</code></td>
<td><code>False</code></td>
</tr>
</tbody>
</table>
<hr />
<p><a name="variable_argument_functions"></a></p>
<h1 id="_38">Функции с переменным количеством аргументов</h1>
<p>В языке Python функции могут иметь фиксированное количество аргументов. Например, функция <code>input()</code>
принимает <code>0</code> или <code>1</code> аргумент: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; print(input('23',' hjk'))
TypeError: input expected at most 1 argument, got 2 (функция не может принимать больше 1 аргумента)</code></pre>
<p>Однако есть функции, которые могут принимать различное количество аргументов, например функция
<code>print()</code> печатает переданное количество аргументов с заданным разделителем. Рассмотрим пример 
написания подобной функции. </p>
<pre class="highlight"><code class="language-code">def minimum(*args):
    if len(args) &lt; 1:
        return None
    min_valiu = args[0]
    for v in args:
        if v &lt; min_valiu:
            min_valiu = v
    return min_valiu

print(minimum()) 
print(minimum(42)) 
print(minimum('b', 'a')) 
print(minimum(2, 3, 5, 0, 1)) </code></pre>
<pre class="highlight"><code class="language-shell">&gt;python delete.py
None
42
a
0</code></pre>
<p>Функция <code>minimum</code> может принимать разное количество аргументов, в том числе ноль. В списке 
аргументов такой функции следует указать <code>*</code> перед именем аргумента. При этом при вызове функции
все переданные ей аргументы представляются как единое значение типа список. </p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Точно такой же синтаксис используется при вызове функции, однако тогда он имеет <strong>совсем 
другое значение</strong> (см. <a href="#spread_operator">здесь</a>).</p>
</div>
<hr />
<p><a name="index_entry_i_44"></a><a name="spread_operator"></a></p>
<h1 id="_39">Распаковка коллекций в аргументы при вызове функции</h1>
<p>Бывают ситуации, когда есть функция принимающая определенное количество аргументов, и есть
коллекция, содержащая соответствующее количество элементов. Например, функция <code>range()</code> может 
принимать три аргумента и, предположим, есть такая коллекция: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; a = [1, 6, 2]</code></pre>
<p>Вызвать функцию <code>range()</code> с аргументами из этого списка можно так: </p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i in range(a[0], a[1], a[2]):
...     print(i)
...
1
3
5</code></pre>
<p>В языке Python есть более короткий способ с использованием так называемой <strong>распаковки коллекций</strong>
(<em>англ.</em> spread operator), которая преобразует коллекцию в отдельные аргументы при вызове функции.
Применяется путем добавления <code>*</code> перед указанием коллекции:</p>
<pre class="highlight"><code class="language-shell">&gt;&gt;&gt; for i in range(*a):
...     print(i)
...
1
3
5</code></pre>
<p>Как можно видеть, результат тот же самый! </p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Данное использование символа <code>*</code> отличается от его использования при определении функции
(см. <a href="#variable_argument_functions">здесь</a>). В данном случае мы функцию не определяем,
а <strong>вызываем</strong>.</p>
</div>
<p>Вот еще один пример использования:</p>
<pre class="highlight"><code class="language-code">a = sorted([int(input()) for _ in range(3)], reverse=True)
print(*a, sep="\n") </code></pre>
<p>На вход программе подается три целых числа, каждое на отдельной строке.
Программа должна вывести три числа, каждое на отдельной строке, упорядоченных от большего к меньшему.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>На самом деле использование распаковки здесь необязательно. Функция <code>min</code> может принимать
 итерируемый объект в качестве единственного аргумента.</p>
</div>
<hr />
<p><img src="../pict/indents.png" class="floatRight" /></p>
<p><a name="index_entry_i_45"></a> </p>
<h1 id="_40">Отступы</h1>
<p>В языке Python отступы используются для структурных частей программы. В отличии от многих других 
языков программирования, в ввиду отсутствия операторных скобок, отступы  и переводы строк являются 
значимыми элементами программного кода. То есть <strong>изменения отступа изменяет поведение программы</strong>.
Рассмотрим пример. Следующая программа определяет являются ли элементы списка частью арифметической 
прогрессии. </p>
<p><a name="index_entry_i_46"></a>
Алгоритм работы программы изобразим в виде <em>блок-схемы</em>, которая иллюстрирует последовательность
выполнения действий и необязательно привязана к конкретному языку. В данном случае блок-схема
определяет отдельные операции ввода и вывода данных, которые мы планируем реализовать в более 
простом виде.</p>
<p style="clear: both;"></p>

<pre class="highlight"><code class="language-code">def is_range(sek):                             # (1)
    if len(sek) &lt; 3:                           # (2)
        return 'NO'                            # (3)
    delta = sek[1] - sek[0]                    # (4)
    for i in range(2, len(sek)):               # (5)
        if sek[i]- sek[i - 1] != delta:        # (6)
            return 'NO'                        # (7)
    return 'YES'                               # (8)

print(is_range([2, 5, 8, 11]))                 # (9)</code></pre>
<p>(1) &mdash; начинается определение функции. Нулевой отступ говорит о том, что это будет обязательно 
выполнено при исполнении модуля ( файла в котором находится этот код). Код в строках  (2...8)
является подчиненным к строке (1). Поэтому строки (1...8) можно условно считать одной ( хотя и 
составной) инструкцией. Следующая инструкция в таком случае, можно считать код в строке (9).</p>
<p>(2) &mdash; один отступ ( 4 пробела). Первая инструкция внутри функции, будет обязательно исполнена при 
вызове функции.</p>
<p>(3) &mdash; тело условия, один отступ внутри родительского (условного) блока, всего два отступа. Данная 
инструкция <code>return</code>, будет выполнена только при определенном условии.</p>
<p>(4) &mdash; один отступ. т. е. можно считать следующим оператором после <code>if</code> (2). В данном случае он 
может не выполниться, если предыдущее условие окажется верным и выполнение функции завершится.
Однако если выполнение функции попадет в строку (4), то эта строка точно будет выполнена. </p>
<div class="admonition danger">
<p class="admonition-title">Возможные ошибки</p>
<p>Если в строке (4) добавить еще один отступ то, она окажется в блоке <code>if</code> после оператора 
<code>return</code>, что в данном случае не имеет смысла потому что после оператора <code>return</code> функция 
завершает выполнение.</p>
<p>К тому же, если условие окажется ложным то (4) строка не выполнится. Следовательно переменная
<code>delta</code> не будет определена, что приведет к ошибке ее использования в строке (6).</p>
</div>
<p>(5) &mdash; один отступ, цикл точно будет выполнен после строки (4).</p>
<p>(6, 7) &mdash; тело цикла, один отступ внутри родительского блока <code>for</code>, итого соответственно 
2 и 3 отступа. Здесь рассуждения те же самые, что и внутри строк (3, 4).</p>
<p>(8) &mdash; один отступ, может быть выполнена <strong>после завершения цикла  for</strong>.  В данном случае внутри 
цикла может произойти возврат значения и, соответственно, завершения работы функции. В этом случае
строка (8) выполнена не будет.   </p>
<div class="admonition danger">
<p class="admonition-title">Возможные ошибки</p>
<p>Если добавить строке (8) еще два отступа, то ошибка будет аналогична предыдущей. Только в 
данном случае ошибки в выполнении не произойдет и программа вместо ответа <code>"Yes"</code> выдаст ответ
<code>None</code>. А это явно не то что нам нужно.</p>
<p>Если в строку (4) добавить один дополнительный отступ, то тогда тело цикла выполнится не более 
одного раза, т. е. будут проверены не все элементы. Это явно не то, что нам нужно.</p>
</div>
<p>(9) &mdash; нулевой отступ, будет обязательно выполнена при исполнении текущего модуля (если, конечно, 
определение функции пройдет без ошибок).</p>
<hr />
<p><a name="index_entry_i_47"></a> </p>
<h1 id="_41">Методы строк</h1>
<h2 id="_42">Поиск и замена</h2>
<p>Методы поиска и замены строк внутри других строк.</p>
<p>Каждый метод в этой группе поддерживает необязательные аргументы <start> и <end>. Как и в 
строковых срезах действие метода ограничено частью исходной строки, начинающейся с позиции 
символа <start> и продолжающейся вплоть до позиции символа <end>, но не включающей ее. Если 
параметр <start> указан, а параметр <end> нет, то метод применяется к части исходной строки от 
<start> до конца строки. Если параметры не заданы, то подразумевается, что <start> = 0 , 
<end> = len(s).</p>
<table>
<thead>
<tr>
<th>Функция</th>
<th>Значение</th>
<th>Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count()</code></td>
<td>считает количество непересекающихся вхождений подстроки в исходную строку</td>
<td></td>
</tr>
<tr>
<td><code>startswith()</code></td>
<td>определяет начинается ли исходная строка s подстрокой <suffix></td>
<td>True/False</td>
</tr>
<tr>
<td><code>endswith()</code></td>
<td>определяет оканчивается ли исходная строка s подстрокой <suffix></td>
<td>True/False</td>
</tr>
<tr>
<td><code>find()</code></td>
<td>находит индекс первого вхождения подстроки <sub> в исходной строке s</td>
<td>-1/ индекс</td>
</tr>
<tr>
<td><code>rfind()</code></td>
<td>он ищет первое вхождение подстроки начиная с конца строки s, если нет то</td>
<td>-1/ индекс</td>
</tr>
<tr>
<td><code>strip()</code></td>
<td>возвращает копию строки s у которой удалены все пробелы стоящие в начале и конце строки</td>
<td></td>
</tr>
<tr>
<td><code>lstrip()</code></td>
<td>возвращает копию строки s у которой удалены все пробелы стоящие в начале строки</td>
<td></td>
</tr>
<tr>
<td><code>rstrip()</code></td>
<td>возвращает копию строки s у которой удалены все пробелы стоящие в конце строки</td>
<td></td>
</tr>
<tr>
<td><code>replace()</code></td>
<td>возвращает копию s со всеми вхождениями подстроки <old>, замененными на <new></td>
<td></td>
</tr>
</tbody>
</table>
<p>s = 'abcdefghij'
Программный код Результат   Пояснение
s[2:5]  cde строка состоящая из символов с индексами 2, 3, 4
s[:5]   abcde   первые пять символов строки
s[5:]   fghij   строка состоящая из символов с индексами от 5 до конца
s[-2:]  ij  последние два символа строки
s[:]    abcdefghij  вся строка целиком
s[1:7:2]    bdf строка состоящая из каждого второго символа с индексами от 1 до 6
s[::-1] jihgfedcba  строка в обратном порядке, так как шаг отрицательный</p>
<p>S.isdigit() Состоит ли строка из цифр</p>
<p>S.isalpha() Состоит ли строка из букв</p>
<p>S.isalnum() Состоит ли строка из цифр или букв</p>
<p>S.islower() Состоит ли строка из символов в нижнем регистре</p>
<p>S.isupper() Состоит ли строка из символов в верхнем регистре</p>
<p>S.isspace() Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), 
"новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная 
табуляция" ('\v'))</p>
<p>S.istitle() Начинаются ли слова в строке с заглавной буквы</p>
<p>S.upper() Преобразование строки к верхнему регистру</p>
<p>S.lower() Преобразование строки к нижнему регистру</p>
<p>S.join(список) Сборка строки из списка с разделителем S</p>
<p>ord(символ) Символ в его код ASCII</p>
<p>chr(число) Код ASCII в символ</p>
<p>S.capitalize() Переводит первый символ строки в верхний регистр, а все остальные в нижний</p>
<p>S.center(width, [fill]) Возвращает отцентрованную строку, по краям которой стоит символ fill 
(пробел по умолчанию)</p>
<p>S.count(str, [start],[end]) Возвращает количество непересекающихся вхождений подстроки в диапазоне 
[начало, конец] (0 и длина строки по умолчанию)</p>
<p>S.expandtabs([tabsize]) Возвращает копию строки, в которой все символы табуляции заменяются одним 
или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер 
табуляции полагается равным 8 пробелам</p>
<p>S.partition(шаблон) Возвращает кортеж, содержащий часть перед первым шаблоном, сам шаблон, и часть 
после шаблона. Если шаблон не найден, возвращается кортеж, содержащий саму строку, а затем две 
пустых строки</p>
<p>S.rpartition(sep) Возвращает кортеж, содержащий часть перед последним шаблоном, сам шаблон, и часть 
после шаблона. Если шаблон не найден, возвращается кортеж, содержащий две пустых строки, а затем 
саму строку</p>
<p>S.swapcase() Переводит символы нижнего регистра в верхний, а верхнего – в нижний</p>
<p>S.title() Первую букву каждого слова переводит в верхний регистр, а все остальные в нижний</p>
<p>S.zfill(width) Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями</p>
<p>S.ljust(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя 
последние символы символом fillchar</p>
<p>S.rjust(width, fillchar=" ") Делает длину строки не меньшей width, по необходимости заполняя первые 
символы символом fillchar</p>
<p>&nbsp;</p>
<hr />

<p style="margin-top:0px;margin-bottom:0px;text-align:right;"><a href="python_working_environment.html" 
title="Previous: Рабочая среда Python"><img src="../layout/pict/previous_page.png"/></a>

<a href="programming_techniques.html" title="Next: Приемы программирования"><img 
src="../layout/pict/next_page.png"/></a>
</p>

<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>
</html>
